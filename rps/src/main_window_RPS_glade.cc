// generated 2003/10/10 13:21:01 CEST by thoma@Tiger.(none)
// using glademm V2.0.0c_cvs
//
// DO NOT EDIT THIS FILE ! It was created using
// glade-- /home/thoma/rollenspiel/rps/rpgs.glade
// for gtk 2.2.4 and gtkmm 2.2.7
//
// Please modify the corresponding derived classes in ./src/main_window_RPS.cc


#if defined __GNUC__ && __GNUC__ < 3
#error This program will crash if compiled with g++ 2.x
// see the dynamic_cast bug in the gtkmm FAQ
#endif //
#include "config.h"
/*
 * Standard gettext macros.
 */
#ifdef ENABLE_NLS
#  include <libintl.h>
#  undef _
#  define _(String) dgettext (GETTEXT_PACKAGE, String)
#  ifdef gettext_noop
#    define N_(String) gettext_noop (String)
#  else
#    define N_(String) (String)
#  endif
#else
#  define textdomain(String) (String)
#  define gettext(String) (String)
#  define dgettext(Domain,Message) (Message)
#  define dcgettext(Domain,Message,Type) (Message)
#  define bindtextdomain(Domain,Directory) (Domain)
#  define _(String) (String)
#  define N_(String) (String)
#endif
#include "main_window_RPS_glade.hh"
#include <gdk/gdkkeysyms.h>
#include <gtkmm/accelgroup.h>
#include <gtkmm/button.h>
#include <gtkmm/image.h>
#include <gtkmm/stockid.h>
#include <gtkmm/toolbar.h>
#include <gtkmm/alignment.h>
#include <gtkmm/scrolledwindow.h>
#include <gtkmm/adjustment.h>
#include <gtkmm/box.h>
#include <gtkmm/eventbox.h>

main_window_RPS_glade::main_window_RPS_glade(
) : Gtk::Window(Gtk::WINDOW_TOPLEVEL)
{  
   
   Gtk::Window *main_window_RPS = this;
   gmm_data = new GlademmData(get_accel_group());
   
   Gtk::Toolbar *toolbar_main = Gtk::manage(new class Gtk::Toolbar());
   Gtk::Alignment *alignment1 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 1, 1));
   treeview_main = Gtk::manage(new class Gtk::TreeView());
   
   Gtk::ScrolledWindow *scrolledwindow1 = Gtk::manage(new class Gtk::ScrolledWindow());
   viewport_playlist = Gtk::manage(new class Gtk::Viewport(*manage(new Gtk::Adjustment(0,0,1)), *manage(new Gtk::Adjustment(0,0,1))));
   scrolledwindow_playlist = Gtk::manage(new class Gtk::ScrolledWindow());
   
   Gtk::HBox *hbox1 = Gtk::manage(new class Gtk::HBox(false, 0));
   Gtk::VBox *vbox2 = Gtk::manage(new class Gtk::VBox(false, 0));
   Gtk::EventBox *eventbox1 = Gtk::manage(new class Gtk::EventBox());
   
   toolbar_main->tools().push_back(Gtk::Toolbar_Helpers::ButtonElem(_("Quit"), *manage(new Gtk::Image(Gtk::StockID("gtk-quit"), Gtk::ICON_SIZE_LARGE_TOOLBAR)), Gtk::Toolbar_Helpers::Callback0()));
   Gtk::Button *button_quit = static_cast<Gtk::Button *>(toolbar_main->tools().back().get_widget());
   toolbar_main->tools().push_back(Gtk::Toolbar_Helpers::Space());
   
   
   toolbar_main->tools().push_back(Gtk::Toolbar_Helpers::ToggleElem(_("Play\n"
		"CDs"), *manage(new Gtk::Image(Gtk::StockID("gtk-cdrom"), Gtk::ICON_SIZE_LARGE_TOOLBAR)), Gtk::Toolbar_Helpers::Callback0()));
   togglebutton_play_dir = static_cast<Gtk::ToggleButton *>(toolbar_main->tools().back().get_widget());
   
   toolbar_main->tools().push_back(Gtk::Toolbar_Helpers::ButtonElem(_("Stop\n"
		"CD"), *manage(new Gtk::Image(Gtk::StockID("gtk-stop"), Gtk::ICON_SIZE_LARGE_TOOLBAR)), Gtk::Toolbar_Helpers::Callback0()));
   Gtk::Button *button_stop_CD = static_cast<Gtk::Button *>(toolbar_main->tools().back().get_widget());
   toolbar_main->tools().push_back(Gtk::Toolbar_Helpers::Space());
   
   
   toolbar_main->tools().push_back(Gtk::Toolbar_Helpers::ToggleElem(_("Repeat"), *manage(new Gtk::Image(Gtk::StockID("gtk-refresh"), Gtk::ICON_SIZE_LARGE_TOOLBAR)), Gtk::Toolbar_Helpers::Callback0()));
   togglebutton_repeat = static_cast<Gtk::ToggleButton *>(toolbar_main->tools().back().get_widget());
   toolbar_main->tools().push_back(Gtk::Toolbar_Helpers::Space());
   
   
   toolbar_main->tools().push_back(Gtk::Toolbar_Helpers::ToggleElem(_("Stop\n"
		"on new"), *manage(new Gtk::Image(Gtk::StockID("gtk-cut"), Gtk::ICON_SIZE_LARGE_TOOLBAR)), Gtk::Toolbar_Helpers::Callback0()));
   togglebutton_kill_on_new = static_cast<Gtk::ToggleButton *>(toolbar_main->tools().back().get_widget());
   
   toolbar_main->tools().push_back(Gtk::Toolbar_Helpers::ButtonElem(_("Stop\n"
		"now"), *manage(new Gtk::Image(Gtk::StockID("gtk-stop"), Gtk::ICON_SIZE_LARGE_TOOLBAR)), Gtk::Toolbar_Helpers::Callback0()));
   Gtk::Button *button_stop_now = static_cast<Gtk::Button *>(toolbar_main->tools().back().get_widget());
   button_quit->set_flags(Gtk::CAN_FOCUS);
   button_quit->grab_focus();
   _tooltips.set_tip(*button_quit, _("Exit the program."), "");
   togglebutton_play_dir->set_flags(Gtk::CAN_FOCUS);
   _tooltips.set_tip(*togglebutton_play_dir, _("Starts to play a CD on expanding the node."), "");
   togglebutton_play_dir->set_active(false);
   _tooltips.set_tip(*button_stop_CD, _("CD stops when the actual piece is done. "), "");
   togglebutton_repeat->set_flags(Gtk::CAN_FOCUS);
   _tooltips.set_tip(*togglebutton_repeat, _("Repeating the selected pieces."), "");
   togglebutton_repeat->set_active(false);
   togglebutton_kill_on_new->set_flags(Gtk::CAN_FOCUS);
   _tooltips.set_tip(*togglebutton_kill_on_new, _("Selecting a piece will stop all other ones immediatly."), "");
   togglebutton_kill_on_new->set_active(false);
   button_stop_now->set_flags(Gtk::CAN_FOCUS);
   _tooltips.set_tip(*button_stop_now, _("Stops playing immediatly"), "");
   toolbar_main->set_tooltips(true);
   alignment1->add(*toolbar_main);
   treeview_main->set_flags(Gtk::CAN_FOCUS);
   treeview_main->set_headers_visible(true);
   treeview_main->set_rules_hint(false);
   treeview_main->set_reorderable(false);
   treeview_main->set_enable_search(true);
   scrolledwindow1->set_flags(Gtk::CAN_FOCUS);
   scrolledwindow1->set_shadow_type(Gtk::SHADOW_NONE);
   scrolledwindow1->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
   scrolledwindow1->property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
   scrolledwindow1->add(*treeview_main);
   viewport_playlist->set_shadow_type(Gtk::SHADOW_IN);
   scrolledwindow_playlist->set_size_request(250,-1);
   scrolledwindow_playlist->set_flags(Gtk::CAN_FOCUS);
   scrolledwindow_playlist->set_shadow_type(Gtk::SHADOW_NONE);
   scrolledwindow_playlist->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
   scrolledwindow_playlist->property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
   scrolledwindow_playlist->add(*viewport_playlist);
   hbox1->pack_start(*scrolledwindow1);
   hbox1->pack_start(*scrolledwindow_playlist, Gtk::PACK_SHRINK, 0);
   vbox2->pack_start(*alignment1, Gtk::PACK_SHRINK, 0);
   vbox2->pack_start(*hbox1);
   eventbox1->set_events(Gdk::EXPOSURE_MASK);
   eventbox1->add(*vbox2);
   main_window_RPS->set_events(Gdk::KEY_RELEASE_MASK);
   main_window_RPS->set_title(_("RolePlayingSound"));
   main_window_RPS->set_modal(false);
   main_window_RPS->property_window_position().set_value(Gtk::WIN_POS_NONE);
   main_window_RPS->set_resizable(true);
   main_window_RPS->property_destroy_with_parent().set_value(false);
   main_window_RPS->add(*eventbox1);
   toolbar_main->set_toolbar_style(Gtk::TOOLBAR_BOTH_HORIZ);
   toolbar_main->show();
   alignment1->show();
   treeview_main->show();
   scrolledwindow1->show();
   viewport_playlist->show();
   scrolledwindow_playlist->show();
   hbox1->show();
   vbox2->show();
   eventbox1->show();
   main_window_RPS->show();
   button_quit->signal_clicked().connect(SigC::slot(*this, &main_window_RPS_glade::on_button_quit_clicked));
   togglebutton_play_dir->signal_toggled().connect(SigC::slot(*this, &main_window_RPS_glade::on_togglebutton_play_dir_toggled));
   button_stop_CD->signal_clicked().connect(SigC::slot(*this, &main_window_RPS_glade::on_button_stop_CD_clicked));
   togglebutton_repeat->signal_toggled().connect(SigC::slot(*this, &main_window_RPS_glade::on_togglebutton_repeat_toggled));
   togglebutton_kill_on_new->signal_toggled().connect(SigC::slot(*this, &main_window_RPS_glade::on_togglebutton_kill_on_new_toggled));
   button_stop_now->signal_clicked().connect(SigC::slot(*this, &main_window_RPS_glade::on_button_stop_now_clicked));
   treeview_main->signal_row_activated().connect(SigC::slot(*this, &main_window_RPS_glade::on_treeview_main_row_activated));
   treeview_main->signal_cursor_changed().connect(SigC::slot(*this, &main_window_RPS_glade::on_treeview_main_cursor_changed));
   treeview_main->signal_move_cursor().connect(SigC::slot(*this, &main_window_RPS_glade::on_treeview_main_move_cursor));
#if 0
   treeview_main->signal_select_cursor_row().connect(SigC::slot(*this, &main_window_RPS_glade::on_treeview_main_select_cursor_row));
   treeview_main->signal_toggle_cursor_row().connect(SigC::slot(*this, &main_window_RPS_glade::on_treeview_main_toggle_cursor_row));
   treeview_main->signal_start_interactive_search().connect(SigC::slot(*this, &main_window_RPS_glade::on_treeview_main_start_interactive_search));
#endif
   treeview_main->signal_button_release_event().connect(SigC::slot(*this, &main_window_RPS_glade::on_treeview_main_button_release_event), true);
   treeview_main->signal_row_expanded().connect(SigC::slot(*this, &main_window_RPS_glade::on_treeview_main_row_expanded));
   main_window_RPS->signal_delete_event().connect(SigC::slot(*this, &main_window_RPS_glade::on_main_window_RPS_delete_event));
}

main_window_RPS_glade::~main_window_RPS_glade()
{  delete gmm_data;
}
